using System.Diagnostics;
using System.Reflection;
using Microsoft.Build.Framework;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using MSBuildTask = Microsoft.Build.Utilities.Task;

namespace Refitter.MSBuild;

public class RefitterGenerateTask : MSBuildTask
{
    public string ProjectFileDirectory { get; set; }

    public bool DisableLogging { get; set; }

    [Output]
    public ITaskItem[] GeneratedFiles { get; set; }

    public override bool Execute()
    {
        TryLogCommandLine($"Starting {nameof(RefitterGenerateTask)}");
        TryLogCommandLine($"Looking for .refitter files under {ProjectFileDirectory}");

        var files = Directory.GetFiles(
            ProjectFileDirectory,
            "*.refitter",
            SearchOption.AllDirectories);

        TryLogCommandLine($"Found {files.Length} .refitter files...");

        var generatedFiles = new List<string>();

        foreach (var file in files)
        {
            TryLogCommandLine($"Processing {file}");
            var generated = TryExecuteRefitter(file);
            if (generated != null)
            {
                generatedFiles.AddRange(generated);
            }
        }

        GeneratedFiles = generatedFiles.Select(f => new Microsoft.Build.Utilities.TaskItem(f)).ToArray();
        TryLogCommandLine($"Generated {GeneratedFiles.Length} files");

        return true;
    }

    private List<string>? TryExecuteRefitter(string file)
    {
        try
        {
            return StartProcess(file);
        }
        catch (Exception e)
        {
            TryLogErrorFromException(e);
            return null;
        }
    }

    private List<string> StartProcess(string file)
    {
        // First, determine what files will be generated by parsing the .refitter file
        var expectedFiles = GetExpectedGeneratedFiles(file);
        
        var assembly = Assembly.GetExecutingAssembly();
        var packageFolder = Path.GetDirectoryName(assembly.Location);
        var seperator = Path.DirectorySeparatorChar;
        
        // Try multiple possible locations for the Refitter CLI
        var refitterDll = $"{packageFolder}{seperator}..{seperator}refitter.dll";
        
        // For development scenarios, try relative to the MSBuild project location
        if (!File.Exists(refitterDll))
        {
            refitterDll = $"{packageFolder}{seperator}..{seperator}..{seperator}..{seperator}Refitter{seperator}bin{seperator}Debug{seperator}net8.0{seperator}refitter.dll";
        }
        
        // If still not found, try in the current project directory
        if (!File.Exists(refitterDll))
        {
            refitterDll = Path.Combine(ProjectFileDirectory!, "..", "..", "src", "Refitter", "bin", "Debug", "net8.0", "refitter.dll");
        }

        var args = $"{refitterDll} --settings-file {file}";
        if (DisableLogging)
        {
            args += " --no-logging";
        }

        if (!File.Exists(refitterDll))
        {
            TryLogError($"Refitter CLI not found at: {refitterDll}");
            TryLogError($"Assembly location: {assembly.Location}");
            TryLogError($"Package folder: {packageFolder}");
            return new List<string>();
        }

        TryLogCommandLine($"Starting dotnet {args}");

        using var process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = "dotnet",
                Arguments = args,
                WorkingDirectory = Path.GetDirectoryName(file)!,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                RedirectStandardInput = true,
                UseShellExecute = false,
                CreateNoWindow = true,
            }
        };

        process.ErrorDataReceived += (_, args) => TryLogError(args.Data);
        process.OutputDataReceived += (_, args) => TryLogCommandLine(args.Data);
        process.Start();
        process.BeginErrorReadLine();
        process.BeginOutputReadLine();
        process.WaitForExit();

        // Return the list of files that should have been generated
        return expectedFiles.Where(File.Exists).ToList();
    }

    private List<string> GetExpectedGeneratedFiles(string refitterFilePath)
    {
        try
        {
            var refitterFileDirectory = Path.GetDirectoryName(refitterFilePath) ?? string.Empty;
            var refitterContent = File.ReadAllText(refitterFilePath);
            var settings = JsonConvert.DeserializeObject<JObject>(refitterContent);

            if (settings == null)
                return new List<string>();

            var outputFolder = settings["outputFolder"]?.ToString();
            var outputFilename = settings["outputFilename"]?.ToString();
            var generateMultipleFiles = settings["generateMultipleFiles"]?.ToObject<bool>() ?? false;
            var contractsOutputFolder = settings["contractsOutputFolder"]?.ToString();

            // If contractsOutputFolder is specified, automatically enable multiple files
            if (!string.IsNullOrWhiteSpace(contractsOutputFolder))
            {
                generateMultipleFiles = true;
            }

            // Default output filename based on .refitter filename if not specified
            if (string.IsNullOrWhiteSpace(outputFilename))
            {
                var refitterFileName = Path.GetFileNameWithoutExtension(refitterFilePath);
                outputFilename = $"{refitterFileName}.cs";
            }

            var generatedFiles = new List<string>();

            if (generateMultipleFiles)
            {
                // Multiple files mode
                var baseOutputFolder = !string.IsNullOrWhiteSpace(outputFolder) ? outputFolder : "./Generated";
                var interfaceOutputPath = Path.GetFullPath(Path.Combine(refitterFileDirectory, baseOutputFolder, "RefitInterfaces.cs"));
                var contractsOutputPath = Path.GetFullPath(Path.Combine(refitterFileDirectory, 
                    !string.IsNullOrWhiteSpace(contractsOutputFolder) ? contractsOutputFolder : baseOutputFolder, 
                    "Contracts.cs"));
                var diOutputPath = Path.GetFullPath(Path.Combine(refitterFileDirectory, baseOutputFolder, "DependencyInjection.cs"));

                generatedFiles.Add(interfaceOutputPath);
                generatedFiles.Add(contractsOutputPath);
                
                // DependencyInjection.cs is only generated if dependencyInjectionSettings are specified
                if (settings["dependencyInjectionSettings"] != null)
                {
                    generatedFiles.Add(diOutputPath);
                }
            }
            else
            {
                // Single file mode
                string outputPath;
                if (!string.IsNullOrWhiteSpace(outputFolder))
                {
                    // outputFolder is specified
                    outputPath = Path.GetFullPath(Path.Combine(refitterFileDirectory, outputFolder, outputFilename));
                }
                else
                {
                    // No outputFolder specified - generate in current directory (default behavior)
                    outputPath = Path.GetFullPath(Path.Combine(refitterFileDirectory, outputFilename));
                }
                generatedFiles.Add(outputPath);
            }

            TryLogCommandLine($"Expected generated files: {string.Join(", ", generatedFiles)}");
            return generatedFiles;
        }
        catch (Exception ex)
        {
            TryLogError($"Error parsing .refitter file {refitterFilePath}: {ex.Message}");
            return new List<string>();
        }
    }

    private void TryLogErrorFromException(Exception e)
    {
        try
        {
            Log.LogErrorFromException(e);
        }
        catch
        {
            // Ignore
        }
    }

    private void TryLogCommandLine(string text)
    {
        try
        {
            Log.LogCommandLine(text);
        }
        catch
        {
            // ignore
        }
    }

    private void TryLogError(string text)
    {
        try
        {
            Log.LogError(text);
        }
        catch
        {
            // ignore
        }
    }
}
